use std::io;
use std::fs;
use std::env;

fn main() {
    // ==============================================
    // Получение данных от пользователя
    // ==============================================
    println!("\n\x1b[36m=== Получение данных от пользователя ===\x1b[0m");
    
    println!("Введите ваше имя:");
    let mut name = String::new();
    io::stdin()
        .read_line(&mut name)
        .expect("Не удалось прочитать строку");
    println!("Привет, \x1b[33m{}\x1b[0m!", name.trim());

    // ==============================================
    // Работа с файлами
    // ==============================================
    println!("\n\x1b[36m=== Работа с файлами ===\x1b[0m");
    
    // Создаем временный файл для демонстрации
    fs::write("temp_example.txt", "Пример содержимого файла\nВторая строка")
        .expect("Не удалось создать файл");
    
    let content = fs::read_to_string("temp_example.txt")
        .expect("Не удалось прочитать файл");
    println!("Содержимое файла:\n\x1b[33m{}\x1b[0m", content);
    
    // Удаляем временный файл
    fs::remove_file("temp_example.txt").expect("Не удалось удалить файл");

    // ==============================================
    // Аргументы командной строки
    // ==============================================
    println!("\n\x1b[36m=== Аргументы командной строки ===\x1b[0m");
    
    let args: Vec<String> = env::args().collect();
    println!("Аргументы программы:");
    for (i, arg) in args.iter().enumerate() {
        println!("  {}: \x1b[33m{}\x1b[0m", i, arg);
    }

    // ==============================================
    // Базовый ввод-вывод
    // ==============================================
    println!("\n\x1b[36m=== Базовый ввод-вывод ===\x1b[0m");
    
    println!("Это обычный вывод (stdout)");
    eprintln!("\x1b[31mЭто вывод в stderr (обычно для ошибок)\x1b[0m");
    
    print!("Этот текст \x1b[33mне\x1b[0m переведёт строку");
    println!(" и этот текст будет на той же строке");

    // ==============================================
    // Форматированный вывод
    // ==============================================
    println!("\n\x1b[36m=== Форматированный вывод ===\x1b[0m");
    
    let name = "Анна";
    let age = 30;
    
    println!("Имя: \x1b[33m{}\x1b[0m, Возраст: \x1b[33m{}\x1b[0m", name, age);
    println!("Имя: \x1b[33m{0}\x1b[0m, Возраст: \x1b[33m{1}\x1b[0m, снова имя: \x1b[33m{0}\x1b[0m", name, age);
    println!("Имя: \x1b[33m{n}\x1b[0m, Возраст: \x1b[33m{a}\x1b[0m", n=name, a=age);

    // ==============================================
    // Преобразование данных
    // ==============================================
    println!("\n\x1b[36m=== Преобразование данных ===\x1b[0m");
    
    // Из строки в число
    let num_str = "42";
    let num: i32 = num_str.parse().expect("Не число!");
    println!("Строка '\x1b[33m{}\x1b[0m' → число \x1b[33m{}\x1b[0m", num_str, num);
    
    // Из числа в строку
    let num = 42;
    let num_str = num.to_string();
    println!("Число \x1b[33m{}\x1b[0m → строка '\x1b[33m{}\x1b[0m'", num, num_str);
    
    // Явное приведение типов
    let x = 42u32;
    let y = x as i64;
    println!("u32 \x1b[33m{}\x1b[0m → i64 \x1b[33m{}\x1b[0m", x, y);
    
    // Обработка ошибок преобразования
    let bad_num = "42a";
    match bad_num.parse::<i32>() {
        Ok(n) => println!("Успешное преобразование: \x1b[33m{}\x1b[0m", n),
        Err(e) => println!("\x1b[31mОшибка преобразования: {}\x1b[0m", e),
    }
}