# Лекция: Заимствование переменных в Rust

## [Введение в Владение](https://doc.rust-lang.ru/book/ch04-01-what-is-ownership.html)

В Rust система заимствования (borrowing) - это ключевой механизм обеспечения безопасности памяти без сборщика мусора. В отличие от владения, при заимствовании переменная не становится собственностью новой области видимости, а лишь временно предоставляет доступ к данным.

## Правила заимствования

1. **Исключительность изменяемых ссылок**: В любой момент времени может существовать:
   - Либо одна изменяемая ссылка (`&mut T`)
   - Либо любое количество неизменяемых ссылок (`&T`)
   
2. **Ссылки должны быть действительными**: Все ссылки должны указывать на действительные данные в памяти (никаких "висячих" ссылок).

## Примеры заимствования

### 1. Неизменяемое заимствование

```rust
fn main() {
    let s = String::from("hello");
    
    // Передаем неизменяемую ссылку
    let len = calculate_length(&s);
    
    // Мы все еще можем использовать s
    println!("Длина '{}' равна {}.", s, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
    // Здесь s выходит из области видимости, но так как это заимствование,
    // String не уничтожается
}
```

### 2. Изменяемое заимствование

```rust
fn main() {
    let mut s = String::from("hello");  // mut обязательно
    
    change_string(&mut s);  // Явно передаем изменяемую ссылку
    
    println!("Изменённая строка: {}", s);
}

fn change_string(s: &mut String) {
    s.push_str(", world!");  // Можем изменять значение
}
```

### 3. Конфликты заимствования

```rust
fn main() {
    let mut s = String::from("hello");
    
    let r1 = &s; // Первое неизменяемое заимствование
    let r2 = &s; // Второе неизменяемое заимствование - OK
    
    // let r3 = &mut s; // ОШИБКА: нельзя изменяемо заимствовать `s`,
                      // пока она заимствована неизменяемо
    
    println!("{} и {}", r1, r2);
    // После этого места r1 и r2 больше не используются
    
    let r3 = &mut s; // Теперь можно - предыдущие ссылки больше не используются
    r3.push_str(", world!");
    println!("{}", r3);
}
```

### 4. Заимствование в циклах

```rust
fn main() {
    let mut vec = vec![1, 2, 3];
    
    // Неизменяемое заимствование в цикле
    for i in &vec {
        println!("{}", i);
        // vec.push(34); // ОШИБКА: нельзя изменять `vec` пока он заимствован
    }
    
    // Изменяемое заимствование в цикле
    for i in &mut vec {
        *i += 10;  // Используем dereference (*) для изменения значения
    }
    
    println!("Измененный вектор: {:?}", vec);
}
```

## Особые случаи заимствования

### 1. Заимствование срезов

```rust
fn main() {
    let s = String::from("hello world");
    
    let hello = &s[0..5];
    let world = &s[6..11];
    
    println!("{} {}", hello, world);
    // s.clear(); // ОШИБКА: нельзя изменять `s` пока существуют заимствованные срезы
}
```

### 2. Возврат заимствований из функций

```rust
fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();
    
    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }
    
    &s[..]
}

fn main() {
    let s = String::from("hello world");
    let word = first_word(&s);
    
    // s.clear(); // ОШИБКА!
    println!("Первое слово: {}", word);
}
```

## Лайфтаймы и заимствование

Хотя в этом примере явно не указаны лайфтаймы, компилятор Rust автоматически определяет, что возвращаемая ссылка должна жить столько же, сколько и входная ссылка.

## Заключение

Система заимствования в Rust обеспечивает безопасность памяти на этапе компиляции, предотвращая:
- Гонки данных (data races)
- Висячие ссылки (dangling references)
- Неожиданные изменения данных

Эти гарантии достигаются без дополнительных накладных расходов во время выполнения программы.